<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lexend+Giga:wght@100..900&display=swap" rel="stylesheet">
    <title>Balok Unfolding Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #ffffff;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        button {
            background: white;
            border: 2px solid #222;
            color: black;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .info-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            border: 2px solid white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 20px;">
        <button id="prevShapeBtn" style="background: white; border: 2px solid #222; color: black; padding: 10px 15px; cursor: pointer; border-radius: 5px; font-size: 30px; line-height: 1;">‹</button>
        
        <div id="geometryTitle" style="padding: 10px 20px; border-radius: 5px; font-family: 'Lexend Giga', sans-serif; font-size: 90px; font-weight: bold;">
            Balok
        </div>
        
        <button id="nextShapeBtn" style="background: white; border: 2px solid #222; color: black; padding: 10px 15px; cursor: pointer; border-radius: 5px; font-size: 30px; line-height: 1;">›</button>
    </div>

    <div id="formulaPanel" style="position: absolute; top: 50%; right: 20px; transform: translateY(-50%); width: 350px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(245, 245, 245, 0.98) 100%); padding: 20px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); font-family: 'Cambria Math', 'Times New Roman', serif; font-size: 25px; color: #222; border: 1px solid rgba(0, 0, 0, 0.1);">
        <h3 style="margin-top: 0; font-size: 28px; border-bottom: 3px solid #000; padding-bottom: 10px;">Rumus Balok</h3>
        <div style="background: rgba(0, 0, 0, 0.03); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #000;">
            <p style="margin: 8px 0;"><strong>Volume:</strong> <span style="font-size: 28px; color: #000;">V = p × l × t</span></p>
            <p style="margin: 8px 0;"><strong>Luas Permukaan:</strong> <span style="font-size: 28px; color: #000;">A = 2(pl + pt + lt)</span></p>
        </div>
        <hr style="border: none; border-top: 2px dashed #ccc; margin: 20px 0;">
        <h4 style="font-size: 24px; margin: 15px 0 10px 0; color: #444;">Contoh</h4>
        <div style="background: rgba(0, 0, 0, 0.05); padding: 15px; border-radius: 8px; border: 2px solid #000;">
            <p id="cuboidParams" style="margin: 8px 0; font-weight: 600; color: #555;">p = 30 cm, l = 20 cm, t = 15 cm</p>
            <p id="cuboidVolume" style="margin: 8px 0; font-size: 22px; color: #000;">V = 9000 cm³</p>
            <p id="cuboidSurface" style="margin: 8px 0; font-size: 22px; color: #000;">A = 2700 cm²</p>
        </div>
    </div>

    <div id="controlPanel" style="position: absolute; top: 50%; left: 20px; transform: translateY(-50%); width: 250px; background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-family: Arial, sans-serif; font-size: 22px; color: #222; text-align: center;">
        <h3 style="margin-top:0;">Kontrol</h3>
        <button id="unfoldBtn" style="margin: 8px 0; width: 100%; padding: 12px; font-size: 20px; background: #000; color: white; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);">
            Buka Jaring
        </button>
        <button id="foldBtn" style="margin: 8px 0; width: 100%; padding: 12px; font-size: 20px; background: white; color: #000; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
            Tutup Jaring
        </button>
        <button id="showInfoBtn" style="margin: 8px 0; width: 100%; padding: 12px; font-size: 20px; background: #000; color: white; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);">
            Tampilkan Info
        </button>
        <button id="resetBtn" style="margin: 8px 0; width: 100%; padding: 12px; font-size: 20px; background: white; color: #000; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
            Reset View
        </button>
        <hr style="margin: 15px 0;">
        <h4 style="margin: 10px 0;">Zoom</h4>
        <div style="display: flex; gap: 8px;">
            <button id="zoomInBtn" style="margin: 0; width: 50%; padding: 12px; font-size: 24px; background: #000; color: white; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 700;">+</button>
            <button id="zoomOutBtn" style="margin: 0; width: 50%; padding: 12px; font-size: 24px; background: white; color: #000; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 700;">−</button>
        </div>
        <hr style="margin: 15px 0;">
        <h4 style="margin: 10px 0;">Ukuran</h4>
        <div style="display: flex; gap: 8px;">
            <button id="addSizeBtn" style="margin: 0; width: 50%; padding: 12px; font-size: 24px; background: #000; color: white; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 700;">+</button>
            <button id="redSizeBtn" style="margin: 0; width: 50%; padding: 12px; font-size: 24px; background: white; color: #000; border: 2px solid #000; border-radius: 8px; cursor: pointer; font-weight: 700;">−</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // Parameters (p = panjang, l = lebar, t = tinggi)
        let length = 3; // panjang (p)
        let width = 2;  // lebar (l)
        let height = 1.5; // tinggi (t)

        // Materials
        const baseMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 1,
        });

        const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2,
            transparent: true,
            opacity: 1,
        });

        // Groups
        const cuboidGroup = new THREE.Group();
        const unfoldedGroup = new THREE.Group();
        scene.add(cuboidGroup, unfoldedGroup);

        // Variables
        let faces = [];
        let showInfo = false;
        let unfolding = false;
        let folding = false;
        let progress = 0;
        let unfoldedState = false;

        // Info Labels
        const infoLabels = [];

        function createInfoLabel(text) {
            const label = document.createElement("div");
            label.className = "info-label";
            label.textContent = text;
            label.style.display = "none";
            document.body.appendChild(label);
            return label;
        }

        const lengthLabel = createInfoLabel("Panjang (p)");
        const widthLabel = createInfoLabel("Lebar (l)");
        const heightLabel = createInfoLabel("Tinggi (t)");

        infoLabels.push(
            { element: lengthLabel, offset: { x: 10, y: 0 } },
            { element: widthLabel, offset: { x: 10, y: 10 } },
            { element: heightLabel, offset: { x: 10, y: -10 } }
        );

        // Create Cuboid
        function createCuboid() {
            while (cuboidGroup.children.length > 0) {
                const child = cuboidGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                cuboidGroup.remove(child);
            }

            faces = [];
            const halfL = length / 2;
            const halfW = width / 2;
            const halfH = height / 2;

            // 6 faces of cuboid
            const faceConfigs = [
                // Front (panjang x tinggi)
                { size: [length, height], pos: [0, 0, halfW], rot: [0, 0, 0], name: 'front' },
                // Back
                { size: [length, height], pos: [0, 0, -halfW], rot: [0, Math.PI, 0], name: 'back' },
                // Top (panjang x lebar)
                { size: [length, width], pos: [0, halfH, 0], rot: [-Math.PI/2, 0, 0], name: 'top' },
                // Bottom
                { size: [length, width], pos: [0, -halfH, 0], rot: [Math.PI/2, 0, 0], name: 'bottom' },
                // Right (lebar x tinggi)
                { size: [width, height], pos: [halfL, 0, 0], rot: [0, Math.PI/2, 0], name: 'right' },
                // Left
                { size: [width, height], pos: [-halfL, 0, 0], rot: [0, -Math.PI/2, 0], name: 'left' }
            ];

            faceConfigs.forEach(config => {
                const geom = new THREE.PlaneGeometry(config.size[0], config.size[1]);
                const mesh = new THREE.Mesh(geom, baseMaterial.clone());
                const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geom), edgeMaterial.clone());
                
                const faceGroup = new THREE.Group();
                faceGroup.add(mesh, edges);
                faceGroup.position.set(...config.pos);
                faceGroup.rotation.set(...config.rot);
                faceGroup.userData.name = config.name;
                faceGroup.userData.initialPos = new THREE.Vector3(...config.pos);
                faceGroup.userData.initialRot = new THREE.Euler(...config.rot);
                
                cuboidGroup.add(faceGroup);
                faces.push(faceGroup);
            });
        }

        // Create Unfolded Net
        function createUnfoldedNet() {
            while (unfoldedGroup.children.length > 0) {
                const child = unfoldedGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                unfoldedGroup.remove(child);
            }

            // Net layout (cross pattern):
            //       [top]
            // [left][front][right][back]
            //       [bottom]

            const netConfigs = [
                { size: [length, height], pos: [0, 0, 0], name: 'front' },
                { size: [length, height], pos: [length + width, 0, 0], name: 'back' },
                { size: [length, width], pos: [0, height/2 + width/2, 0], name: 'top' },
                { size: [length, width], pos: [0, -(height/2 + width/2), 0], name: 'bottom' },
                { size: [width, height], pos: [length/2 + width/2, 0, 0], name: 'right' },
                { size: [width, height], pos: [-(length/2 + width/2), 0, 0], name: 'left' }
            ];

            netConfigs.forEach(config => {
                const geom = new THREE.PlaneGeometry(config.size[0], config.size[1]);
                const mesh = new THREE.Mesh(geom, baseMaterial.clone());
                const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geom), edgeMaterial.clone());
                
                const faceGroup = new THREE.Group();
                faceGroup.add(mesh, edges);
                faceGroup.position.set(...config.pos);
                faceGroup.userData.name = config.name;
                mesh.material.opacity = 0;
                edges.material.opacity = 0;
                
                unfoldedGroup.add(faceGroup);
            });

            unfoldedGroup.visible = false;
        }

        // Update Formulas
        function updateFormulas() {
            const p = length * 10;
            const l = width * 10;
            const t = height * 10;
            const v = p * l * t;
            const a = 2 * (p * l + p * t + l * t);

            document.getElementById("cuboidParams").textContent = `p = ${p.toFixed(0)} cm, l = ${l.toFixed(0)} cm, t = ${t.toFixed(0)} cm`;
            document.getElementById("cuboidVolume").textContent = `V = ${v.toFixed(0)} cm³`;
            document.getElementById("cuboidSurface").textContent = `A = ${a.toFixed(0)} cm²`;
        }

        // Update Info Labels
        function updateInfoLabels() {
            if (!showInfo || unfolding || folding) {
                infoLabels.forEach(label => label.element.style.display = "none");
                return;
            }

            const targetGroup = unfoldedState ? unfoldedGroup : cuboidGroup;
            const positions = unfoldedState ? 
                [
                    new THREE.Vector3(length/2, 0, 0.01),
                    new THREE.Vector3(0, width/2, 0.01),
                    new THREE.Vector3(0, height/2 + width/2, 0.01)
                ] : 
                [
                    new THREE.Vector3(length/2, 0, width/2),
                    new THREE.Vector3(0, 0, width/2),
                    new THREE.Vector3(length/2, height/2, 0)
                ];

            infoLabels.forEach((label, i) => {
                const position = positions[i].clone();
                position.applyMatrix4(targetGroup.matrixWorld);
                const vector = position.project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                label.element.style.left = `${x + label.offset.x}px`;
                label.element.style.top = `${y + label.offset.y}px`;
                label.element.style.display = "block";
            });
        }

        // Easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Apply unfold transform
        function applyUnfoldTransform(easedProgress) {
            const halfL = length / 2;
            const halfW = width / 2;
            const halfH = height / 2;

            faces.forEach(face => {
                const name = face.userData.name;
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Euler();

                // Calculate target positions in unfolded net
                switch(name) {
                    case 'front':
                        targetPos.set(0, 0, 0);
                        targetRot.set(0, 0, 0);
                        break;
                    case 'back':
                        targetPos.set(length + width, 0, 0);
                        targetRot.set(0, Math.PI, 0);
                        break;
                    case 'top':
                        targetPos.set(0, halfH + halfW, 0);
                        targetRot.set(Math.PI/2, 0, 0);
                        break;
                    case 'bottom':
                        targetPos.set(0, -(halfH + halfW), 0);
                        targetRot.set(-Math.PI/2, 0, 0);
                        break;
                    case 'right':
                        targetPos.set(halfL + halfW, 0, 0);
                        targetRot.set(0, -Math.PI/2, 0);
                        break;
                    case 'left':
                        targetPos.set(-(halfL + halfW), 0, 0);
                        targetRot.set(0, Math.PI/2, 0);
                        break;
                }

                face.position.lerpVectors(face.userData.initialPos, targetPos, easedProgress);
                face.rotation.x = THREE.MathUtils.lerp(face.userData.initialRot.x, targetRot.x, easedProgress);
                face.rotation.y = THREE.MathUtils.lerp(face.userData.initialRot.y, targetRot.y, easedProgress);
                face.rotation.z = THREE.MathUtils.lerp(face.userData.initialRot.z, targetRot.z, easedProgress);

                face.children.forEach(child => {
                    if (child.material) child.material.opacity = 1 - easedProgress;
                });
            });

            unfoldedGroup.traverse(child => {
                if (child.material) child.material.opacity = easedProgress;
            });
        }

        // Button handlers
        function updateButtonStyles() {
            const unfoldBtn = document.getElementById("unfoldBtn");
            const foldBtn = document.getElementById("foldBtn");
            
            if (unfoldedState) {
                unfoldBtn.style.background = "white";
                unfoldBtn.style.color = "#000";
                foldBtn.style.background = "#000";
                foldBtn.style.color = "white";
            } else {
                unfoldBtn.style.background = "#000";
                unfoldBtn.style.color = "white";
                foldBtn.style.background = "white";
                foldBtn.style.color = "#000";
            }
        }

        document.getElementById("unfoldBtn").addEventListener("click", () => {
            if (unfolding || unfoldedState) return;
            unfolding = true;
            folding = false;
            progress = 0;
            if (showInfo) {
                infoLabels.forEach(l => l.element.style.display = "none");
                showInfo = false;
                document.getElementById("showInfoBtn").textContent = "Tampilkan Info";
            }
        });

        document.getElementById("foldBtn").addEventListener("click", () => {
            if (folding || !unfoldedState) return;
            folding = true;
            unfolding = false;
            progress = 1;
        });

        document.getElementById("resetBtn").addEventListener("click", () => {
            camera.position.set(5, 4, 6);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        document.getElementById("showInfoBtn").addEventListener("click", () => {
            if (unfolding || folding) return;
            showInfo = !showInfo;
            const btn = document.getElementById("showInfoBtn");
            btn.textContent = showInfo ? "Sembunyikan Info" : "Tampilkan Info";
            updateInfoLabels();
        });

        document.getElementById("zoomInBtn").addEventListener("click", () => {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            camera.position.addScaledVector(dir, 0.5);
            controls.update();
        });

        document.getElementById("zoomOutBtn").addEventListener("click", () => {
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            camera.position.addScaledVector(dir, -0.5);
            controls.update();
        });

        document.getElementById("addSizeBtn").addEventListener("click", () => {
            if (length <= 5) {
                length += 0.2;
                width += 0.15;
                height += 0.1;
                createCuboid();
                createUnfoldedNet();
                updateFormulas();
                unfoldedState = false;
                updateButtonStyles();
                cuboidGroup.visible = true;
                unfoldedGroup.visible = false;
            }
        });

        document.getElementById("redSizeBtn").addEventListener("click", () => {
            if (length > 1) {
                length -= 0.2;
                width -= 0.15;
                height -= 0.1;
                createCuboid();
                createUnfoldedNet();
                updateFormulas();
                unfoldedState = false;
                updateButtonStyles();
                cuboidGroup.visible = true;
                unfoldedGroup.visible = false;
            }
        });

        // Initialize
        createCuboid();
        createUnfoldedNet();
        updateFormulas();
        updateButtonStyles();

        // Navigation buttons
        document.getElementById("prevShapeBtn").addEventListener("click", () => {
            window.location.href = "pyramid.html";
        });

        document.getElementById("nextShapeBtn").addEventListener("click", () => {
            window.location.href = "cube.html";
        });

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            const speed = 0.8;

            if (unfolding) {
                progress += dt * speed;
                if (progress >= 1) {
                    progress = 1;
                    unfolding = false;
                    unfoldedState = true;
                    updateButtonStyles();
                    cuboidGroup.visible = false;
                    unfoldedGroup.visible = true;
                }
            } else if (folding) {
                progress -= dt * speed;
                if (progress <= 0) {
                    progress = 0;
                    folding = false;
                    unfoldedState = false;
                    updateButtonStyles();
                    cuboidGroup.visible = true;
                    unfoldedGroup.visible = false;
                }
            }

            if (unfolding || folding) {
                cuboidGroup.visible = true;
                unfoldedGroup.visible = true;
                const eased = easeInOutCubic(progress);
                applyUnfoldTransform(eased);
            }

            controls.update();
            renderer.render(scene, camera);
            updateInfoLabels();
        }
        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
